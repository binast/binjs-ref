
// Deprecated trait. Any new implementation should use TokenWriter.
pub trait TokenWriterWithTree where Self::Statistics: Display + Sized + Add + Default {
    /// Statistics produced by this writer.
    type Statistics;

    type Tree;

    /// The type of data generated by this writer.
    /// Typically some variant of `Vec<u8>`.
    type Data: AsRef<[u8]>;

    /// Finish writing, produce data.
    fn done(self) -> Result<(Self::Data, Self::Statistics), TokenWriterError>;

    /// Write a tagged tuple.
    ///
    /// The number of items is specified by the grammar, so it MAY not be
    /// recorded by the `TokenWriter`.
    ///
    /// By convention, a null tagged tuple is the special tagged tuple "null",
    /// with no children.
    fn tagged_tuple(&mut self, _tag: &InterfaceName, _children: &[(FieldName, Self::Tree)]) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn tagged_tuple_at(&mut self, tag: &InterfaceName, children: &[(FieldName, Self::Tree)], _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.tagged_tuple(tag, children)
    }
    fn enter_tagged_tuple_at(&mut self, _tag: &InterfaceName, _children: usize, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }
    fn exit_tagged_tuple_at(&mut self, _tag: &InterfaceName, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }

    /// Write a list.
    ///
    /// By opposition to a tuple, the number of items is variable and MUST
    /// be somehow recorded by the `TokenWriter`.
    fn list(&mut self, Vec<Self::Tree>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn list_at(&mut self, items: Vec<Self::Tree>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.list(items)
    }
    fn enter_list_at(&mut self, _len: usize, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }
    fn exit_list_at(&mut self, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }

    /// Write a single UTF-8 string.
    ///
    /// If specified, the string MUST be UTF-8.
    fn string(&mut self, Option<&SharedString>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn string_at(&mut self, value: Option<&SharedString>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.string(value)
    }

    /// Write a single UTF-8 value from a string enumeration.
    ///
    /// The default implementation uses `self.string``, but some encodings may use
    /// the extra information e.g. to represent the enumeration by an index in the
    /// list of possible values, or to encode string enums as interfaces.
    fn string_enum(&mut self, str: &SharedString) -> Result<Self::Tree, TokenWriterError> {
        self.string(Some(str))
    }
    fn string_enum_at(&mut self, value: &SharedString, path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.string_at(Some(value), path)
    }

    /// Write a single number.
    fn float(&mut self, Option<f64>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn float_at(&mut self, value: Option<f64>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.float(value)
    }

    /// Write a single u32.
    fn unsigned_long(&mut self, u32) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn unsigned_long_at(&mut self, value: u32, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.unsigned_long(value)
    }

    /// Write single bool.
    // FIXME: Split `bool` from `maybe_bool`.
    fn bool(&mut self, Option<bool>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn bool_at(&mut self, value: Option<bool>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.bool(value)
    }

    /// Write the number of bytes left in this tuple.
    fn offset(&mut self) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn offset_at(&mut self, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.offset()
    }

    fn property_key(&mut self, value: Option<&PropertyKey>) -> Result<Self::Tree, TokenWriterError> {
        let string = value.map(PropertyKey::as_shared_string);
        self.string(string)
    }
    fn property_key_at(&mut self, value: Option<&PropertyKey>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.property_key(value)
    }
    // FIXME: Split `property_key` from `maybe_property_key`.

    fn identifier_name(&mut self, value: Option<&IdentifierName>) -> Result<Self::Tree, TokenWriterError> {
        let string = value.map(IdentifierName::as_shared_string);
        self.string(string)
    }
    fn identifier_name_at(&mut self, value: Option<&IdentifierName>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.identifier_name(value)
    }
    // FIXME: Split `identifier_name` from `maybe_identifier_name`.
}

pub struct TokenWriterTreeAdapter<T> where T: TokenWriterWithTree {
    writer: T,
    stack: Vec<Vec<T::Tree>>,
}
impl<T> TokenWriter for TokenWriterTreeAdapter<T> where T: TokenWriterWithTree {
    type Statistics = T::Statistics;
    type Data = T::Data;


    /// Write a tagged tuple.
    ///
    /// The number of items is specified by the grammar, so it MAY not be
    /// recorded by the `TokenWriter`.
    ///
    /// By convention, a null tagged tuple is the special tagged tuple "null",
    /// with no children.
    fn enter_tagged_tuple_at(&mut self, _tag: &InterfaceName, _children: usize, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }
    fn exit_tagged_tuple_at(&mut self, _tag: &InterfaceName, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }

    /// Write a list.
    ///
    /// By opposition to a tuple, the number of items is variable and MUST
    /// be somehow recorded by the `TokenWriter`.
    fn enter_list_at(&mut self, _len: usize, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }
    fn exit_list_at(&mut self, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }

    /// Write a single UTF-8 string.
    ///
    /// If specified, the string MUST be UTF-8.
    fn string(&mut self, Option<&SharedString>) -> Result<(), TokenWriterError> {
        unimplemented!()
    }
    fn string_at(&mut self, value: Option<&SharedString>, _path: &Path) -> Result<(), TokenWriterError> {
        self.string(value)
    }

    /// Write a single UTF-8 value from a string enumeration.
    ///
    /// The default implementation uses `self.string``, but some encodings may use
    /// the extra information e.g. to represent the enumeration by an index in the
    /// list of possible values, or to encode string enums as interfaces.
    fn string_enum(&mut self, str: &SharedString) -> Result<(), TokenWriterError> {
        self.string(Some(str))
    }
    fn string_enum_at(&mut self, value: &SharedString, path: &Path) -> Result<(), TokenWriterError> {
        self.string_at(Some(value), path)
    }

    /// Write a single number.
    fn float(&mut self, Option<f64>) -> Result<(), TokenWriterError> {
        unimplemented!()
    }
    fn float_at(&mut self, value: Option<f64>, _path: &Path) -> Result<(), TokenWriterError> {
        self.float(value)
    }

    /// Write a single u32.
    fn unsigned_long(&mut self, u32) -> Result<(), TokenWriterError> {
        unimplemented!()
    }
    fn unsigned_long_at(&mut self, value: u32, _path: &Path) -> Result<(), TokenWriterError> {
        self.unsigned_long(value)
    }

    /// Write single bool.
    // FIXME: Split `bool` from `maybe_bool`.
    fn bool(&mut self, Option<bool>) -> Result<(), TokenWriterError> {
        unimplemented!()
    }
    fn bool_at(&mut self, value: Option<bool>, _path: &Path) -> Result<(), TokenWriterError> {
        self.bool(value)
    }

    /// Write the number of bytes left in this tuple.
    fn offset(&mut self) -> Result<(), TokenWriterError> {
        unimplemented!()
    }
    fn offset_at(&mut self, _path: &Path) -> Result<(), TokenWriterError> {
        self.offset()
    }

    fn property_key(&mut self, value: Option<&PropertyKey>) -> Result<(), TokenWriterError> {
        let string = value.map(PropertyKey::as_shared_string);
        self.string(string)
    }
    fn property_key_at(&mut self, value: Option<&PropertyKey>, _path: &Path) -> Result<(), TokenWriterError> {
        self.property_key(value)
    }
    // FIXME: Split `property_key` from `maybe_property_key`.

    fn identifier_name(&mut self, value: Option<&IdentifierName>) -> Result<(), TokenWriterError> {
        let string = value.map(IdentifierName::as_shared_string);
        self.string(string)
    }
    fn identifier_name_at(&mut self, value: Option<&IdentifierName>, _path: &Path) -> Result<(), TokenWriterError> {
        self.identifier_name(value)
    }
    // FIXME: Split `identifier_name` from `maybe_identifier_name`.
}

// Deprecated trait. Any new implementation should use TokenWriter.
pub trait TokenWriterWithTree where Self::Statistics: Display + Sized + Add + Default {
    /// Statistics produced by this writer.
    type Statistics;

    type Tree;

    /// The type of data generated by this writer.
    /// Typically some variant of `Vec<u8>`.
    type Data: AsRef<[u8]>;

    /// Finish writing, produce data.
    fn done(self) -> Result<(Self::Data, Self::Statistics), TokenWriterError>;

    /// Write a tagged tuple.
    ///
    /// The number of items is specified by the grammar, so it MAY not be
    /// recorded by the `TokenWriter`.
    ///
    /// By convention, a null tagged tuple is the special tagged tuple "null",
    /// with no children.
    fn tagged_tuple(&mut self, _tag: &InterfaceName, _children: &[(FieldName, Self::Tree)]) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn tagged_tuple_at(&mut self, tag: &InterfaceName, children: &[(FieldName, Self::Tree)], _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.tagged_tuple(tag, children)
    }
    fn enter_tagged_tuple_at(&mut self, _tag: &InterfaceName, _children: usize, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }
    fn exit_tagged_tuple_at(&mut self, _tag: &InterfaceName, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }

    /// Write a list.
    ///
    /// By opposition to a tuple, the number of items is variable and MUST
    /// be somehow recorded by the `TokenWriter`.
    fn list(&mut self, Vec<Self::Tree>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn list_at(&mut self, items: Vec<Self::Tree>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.list(items)
    }
    fn enter_list_at(&mut self, _len: usize, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }
    fn exit_list_at(&mut self, _path: &Path) -> Result<(), TokenWriterError> {
        Ok(())
    }

    /// Write a single UTF-8 string.
    ///
    /// If specified, the string MUST be UTF-8.
    fn string(&mut self, Option<&SharedString>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn string_at(&mut self, value: Option<&SharedString>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.string(value)
    }

    /// Write a single UTF-8 value from a string enumeration.
    ///
    /// The default implementation uses `self.string``, but some encodings may use
    /// the extra information e.g. to represent the enumeration by an index in the
    /// list of possible values, or to encode string enums as interfaces.
    fn string_enum(&mut self, str: &SharedString) -> Result<Self::Tree, TokenWriterError> {
        self.string(Some(str))
    }
    fn string_enum_at(&mut self, value: &SharedString, path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.string_at(Some(value), path)
    }

    /// Write a single number.
    fn float(&mut self, Option<f64>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn float_at(&mut self, value: Option<f64>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.float(value)
    }

    /// Write a single u32.
    fn unsigned_long(&mut self, u32) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn unsigned_long_at(&mut self, value: u32, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.unsigned_long(value)
    }

    /// Write single bool.
    // FIXME: Split `bool` from `maybe_bool`.
    fn bool(&mut self, Option<bool>) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn bool_at(&mut self, value: Option<bool>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.bool(value)
    }

    /// Write the number of bytes left in this tuple.
    fn offset(&mut self) -> Result<Self::Tree, TokenWriterError> {
        unimplemented!()
    }
    fn offset_at(&mut self, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.offset()
    }

    fn property_key(&mut self, value: Option<&PropertyKey>) -> Result<Self::Tree, TokenWriterError> {
        let string = value.map(PropertyKey::as_shared_string);
        self.string(string)
    }
    fn property_key_at(&mut self, value: Option<&PropertyKey>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.property_key(value)
    }
    // FIXME: Split `property_key` from `maybe_property_key`.

    fn identifier_name(&mut self, value: Option<&IdentifierName>) -> Result<Self::Tree, TokenWriterError> {
        let string = value.map(IdentifierName::as_shared_string);
        self.string(string)
    }
    fn identifier_name_at(&mut self, value: Option<&IdentifierName>, _path: &Path) -> Result<Self::Tree, TokenWriterError> {
        self.identifier_name(value)
    }

    fn done(self) -> Result<(Self::Data, Self::Statistics), TokenWriterError> {
        self.writer.done()
    }
}
